#!/bin/bash
set -eu
OUTDIR=$(dirname "$1")
TARGET=$(basename "$1")

# Docs:
# https://v8.dev/docs/build-gn
# https://v8.dev/docs/compile-arm64

# Note: libc++ is (basically) required to build v8 on clang. On clang `libstdc++` can't inline
# unaligned 64-bit atomic struct operations. So you'd need to link against libatomic which I don't
# want to do because you don't need to.
# https://github.com/llvm/llvm-project/issues/44400
# ---
# #include <atomic>
# struct foo_t { uint32_t left, right; };
# int main() {
#   std::atomic<foo_t> foo;
#   foo_t one, two;
#   foo.compare_exchange_strong(one, two);
# }
# ---
# g++ a.cc
# clang++ -stdlib=libc++ a.cc
# clang++ -stdlib=libstdc++ a.cc
# /usr/bin/ld: /tmp/a-f7f4f4.o: in function `std::atomic<foo_t>::compare_exchange_strong(foo_t&, foo_t, std::memory_order, std::memory_order)':
# a.cc:(.text._ZNSt6atomicI5foo_tE23compare_exchange_strongERS0_S0_St12memory_orderS3_[_ZNSt6atomicI5foo_tE23compare_exchange_strongERS0_S0_St12memory_orderS3_]+0x6a): undefined reference to `__atomic_compare_exchange'
# clang++: error: linker command failed with exit code 1 (use -v to see invocation)

# shellcheck disable=SC2206
TUPLE=(${TARGET//./ })
PLATFORM=${TUPLE[${#TUPLE[@]} - 3]:-} # linux-gnu, linux-musl, windows, darwin
ARCH=${TUPLE[${#TUPLE[@]} - 2]} # x64, arm64
CONFIG=${TUPLE[${#TUPLE[@]} - 1]} # release, debug, optdebug

# `use_custom_libcxx=false`
# Use the system default c++ standard library. The v8 maintainers really won't like you if you do
# this.

# `use_lld=true` (default)
# Use `lld` (llvm linker). This enables CREL ELF relocation tables on Linux, so LLD must be also
# used to build isolated-vm in that case.

# `v8_enable_temporal_support=false`
# Disables Temporal, which requires a Rust x86 toolchain for some reason.
# https://issues.chromium.org/issues/425709639

GN_ARGS=(
	clang_use_chrome_plugins=false
	treat_warnings_as_errors=false
	use_clang_modules=false
	use_custom_libcxx=false
	use_lld=false
	v8_enable_direct_handle=true
	v8_enable_partition_alloc=false
	v8_enable_sandbox=true
	v8_enable_temporal_support=false
	v8_use_external_startup_data=false
);
if [ ${CLANG_BASE_PATH+-} ]; then
	CLANG_VERSION=$("$CLANG_BASE_PATH/bin/clang" --version | sed -nE 's/^.*version ([0-9]+).*$/\1/p')
	GN_ARGS+=(
		clang_base_path="\"$CLANG_BASE_PATH\""
		clang_version="\"$CLANG_VERSION\""
		is_clang=true
	)
elif [ "$PLATFORM" = win32 ]; then
	# clang-cl is used.
	GN_ARGS+=(is_clang=true)
else
	# v8 drops support for gcc wow
	# https://groups.google.com/a/chromium.org/g/chromium-dev/c/5haWEDpUK6Y/m/LkM8f4CrDAAJ
	# https://groups.google.com/g/v8-users/c/-vbS2agi1Kw
	GN_ARGS+=(
		is_clang=false
		is_gcc=true
	)
fi
if [ ${WITHOUT_SYSROOT+-} ]; then
	GN_ARGS+=(use_sysroot=false)
fi

# Platform flags
case "$PLATFORM" in
	darwin)
		# This lets us link against the system libc++ dylib using the modern llvm headers.
		mkdir -p "$OUTDIR/$TARGET/obj"
		cat <<-EOF | clang++ -xc++ - -std=c++20 -mmacos-version-min=12.0 -O3 -c -o "$OUTDIR/$TARGET/obj/std_hash.o"
			#include <cstddef>
			#include <string_view>
			#include <utility>
			namespace std::inline __1 {
			auto __hash_memory([[_Clang::__noescape__]] const void* ptr, size_t size) noexcept -> size_t {
				std::hash<std::string_view> hash{};
				return hash(std::string_view{static_cast<const char*>(ptr), size});
			}
			}
		EOF
		;;
	linux-musl)
		GN_ARGS+=(
			use_glib=false
			use_sysroot=false
		)
		;;
esac

# Optimization & diagnostic flags
case "$CONFIG" in
	debug|optdebug)
		GN_ARGS+=(
			is_debug=true
			symbol_level=2
			v8_enable_backtrace=true
			v8_enable_disassembler=true
			v8_enable_fast_mksnapshot=true
			v8_enable_object_print=true
			v8_enable_slow_dchecks=true
			v8_enable_verify_heap=true
		)
		GN_ARGS+=(v8_optimized_debug=false)
		if [ "$CONFIG" = debug ]; then
			# Default is `true`
			GN_ARGS+=(v8_optimized_debug=false)
		fi
		;;
	release)
		GN_ARGS+=(
			dcheck_always_on=false
			is_debug=false
		)
		;;
esac

# Static vs shared library build
case "$CONFIG" in
	debug)
		V8_LIBRARY_TYPE=shared
		V8_TARGETS=(v8 v8_libbase v8_libplatform)
		;;
	optdebug|release)
		GN_ARGS+=(
			is_component_build=false
			v8_monolithic_for_shared_library=true
			v8_monolithic=true
		)
		if [ "$CONFIG" = optdebug ]; then
			# Don't split debug
			GN_ARGS+=(use_debug_fission=false)
		fi
		V8_LIBRARY_TYPE=static
		V8_TARGETS=(v8_monolith)
		;;
esac

# Configure gn / ninja
echo gn gen "$OUTDIR/$TARGET" --args=\'"${GN_ARGS[*]}"\'
gn gen "$OUTDIR/$TARGET" --args="${GN_ARGS[*]}"

# Make v8-gn.h
mkdir -p "$OUTDIR/$TARGET/include"
echo > "$OUTDIR/$TARGET/include/v8-gn.h" "#pragma once"
DEFINES=$(grep 'defines = ' "$OUTDIR/$TARGET/obj/v8_compiler.ninja" | grep -Eoi -- '-D[A-Z0-9_=]+\b' | cut -c3-)
USED_DEFINES=$(grep -REoh -- "$(echo -n "${DEFINES}" | sed -r 's/\\b([A-Z0-9_]+)=?.+\\b/\1/g' | tr '\n' '|')" include | sort | uniq)
echo "$DEFINES" | while read -r LINE; do
	# shellcheck disable=SC2206
	PAIR=(${LINE//=/ })
	FLAG=${PAIR[0]}
	VALUE=${PAIR[1]:-}
	if [[ "$USED_DEFINES" == *"$FLAG"* ]]; then
		if [[ "$VALUE" == '' ]]; then
			VALUE=1
		fi
		echo "#define $FLAG $VALUE" >> "$OUTDIR/$TARGET/include/v8-gn.h"
	fi
done

# Make `env`
cat <<EOF > "$OUTDIR/$TARGET/env"
V8_INCLUDE_GN_FILE=$(realpath "$OUTDIR/$TARGET/include/v8-gn.h")
V8_INCLUDE_DIR=$(realpath "$OUTDIR/include")
V8_LIBRARY_TYPE=$V8_LIBRARY_TYPE
V8_OUT_PATH=$(realpath "$OUTDIR/$TARGET")
EOF

# Build the monolith
ninja -C "$OUTDIR/$TARGET" v8 "${V8_TARGETS[@]}"
